# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_metrics.ipynb (unless otherwise specified).

__all__ = ['IoU']

# Cell
import tensorflow as tf
from tensorflow.python.ops import math_ops, confusion_matrix, array_ops, init_ops
from tensorflow.python.framework import dtypes

# Cell
class IoU(tf.keras.metrics.MeanIoU):
    """
    Computes the Intersection-Over-Union metric.
    Adjusted for probabilistic labels and different semantic classes from
    tf.keras.metrics.MeanIoU
    (https://www.tensorflow.org/api_docs/python/tf/keras/metrics/MeanIoU)

    Mean Intersection-Over-Union is a common evaluation metric for semantic image
    segmentation, which first computes the IOU for each semantic class and then
    computes the average over classes. IOU is defined as follows:
    IOU = true_positive / (true_positive + false_positive + false_negative).
    The predictions are accumulated in a confusion matrix, weighted by
    `sample_weight` and the metric is then calculated from it.

    If `class_id` is specified, we calculate the IoU by considering only the
    entries in the batch for which `class_id` is in the label
     """
    def __init__(self,
                 num_classes,
                 class_id = None,
                 name=None,
                 dtype=None):
        super().__init__(num_classes=num_classes, name=name, dtype=dtype)
        self.class_id = class_id

    def update_state(self, y_true, y_pred, sample_weight=None):
        """Accumulates the confusion matrix statistics.
        Args:
          y_true: The ground truth values.
          y_pred: The predicted values.
          sample_weight: Optional weighting of each example. Defaults to 1. Can be a
            `Tensor` whose rank is either 0, or the same rank as `y_true`, and must
            be broadcastable to `y_true`.
        Returns:
          Update op.
        """
        if self.class_id is not None:
            y_true = y_true[..., self.class_id]
            y_pred = y_pred[..., self.class_id]

        y_pred = tf.math.round(y_pred)
        y_true = math_ops.cast(y_true, self._dtype)
        y_pred = math_ops.cast(y_pred, self._dtype)

        # Flatten the input if its rank > 1.
        if y_pred.shape.ndims > 1:
              y_pred = array_ops.reshape(y_pred, [-1])

        if y_true.shape.ndims > 1:
              y_true = array_ops.reshape(y_true, [-1])

        if sample_weight is not None and sample_weight.shape.ndims > 1:
              sample_weight = array_ops.reshape(sample_weight, [-1])

        # Accumulate the prediction to current confusion matrix.
        current_cm = confusion_matrix.confusion_matrix(
            y_true,
            y_pred,
            self.num_classes,
            weights=sample_weight,
            dtype=dtypes.float64)
        return self.total_cm.assign_add(current_cm)