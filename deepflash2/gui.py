# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/08_gui.ipynb (unless otherwise specified).

__all__ = ['GRID_COLS', 'set_css_in_cell_output', 'tooltip_css', 'query_yes_no', 'ZipUpload', 'ItemsPerPage',
           'BaseParamWidget', 'BaseUI', 'PathSelector', 'PathDownloads', 'PathConfig', 'GTDataSB', 'GTEstSB', 'GTEstUI',
           'TrainDataSB', 'TrainModelSB', 'TrainValidSB', 'LRWidget', 'BasePopUpParamWidget', 'ParamWidget', 'MWWidget',
           'TrainUI', 'PredInputSB', 'PredSB', 'PredUI', 'GUI']

# Cell
import sys, shutil, time, zipfile, urllib, subprocess
import ipywidgets as w, numpy as np, pandas as pd, IPython.display as d
from pathlib import Path
from fastcore.foundation import store_attr
from fastcore.basics import GetAttr
import matplotlib.pyplot as plt

from .utils import unzip, get_label_fn
from .learner import EnsembleLearner, Config, _optim_dict, _archs, _pretrained
from .gt import GTEstimator

try:
    from google import colab
    COLAB = True
except ImportError:
    COLAB = False

GRID_COLS = 2

# Cell
_descr = {
    #GT
    'exp' : ('Expert Masks*', 'The parent folder containing sub-folders with segmentation masks, one folder per expert.', 'https://matjesg.github.io/deepflash2/add_information.html#Naming'),
    'up_gt': ('Upload Data', 'Upload a zip file. It will be extracted automatically and must contain sub-folders with segmentation masks, one folder per expert.'),
    'staple': ("STAPLE", "Simultaneous truth and performance level estimation (STAPLE)", "https://pubmed.ncbi.nlm.nih.gov/15250643/"),
    'mv'  :("Majority Voting", "Pixelwise majority voting to obtain the reference segmentation.", "https://simpleitk.org/doxygen/latest/html/classitk_1_1simple_1_1LabelVotingImageFilter.html"),

    #Train
    'img' : ('Image Folder*', 'One folder containing all training images.', 'https://matjesg.github.io/deepflash2/add_information.html#Naming'),
    'msk' : ('Mask Folder*', 'One folder containing all segmentation masks. We highly recommend using ground truth estimation from multiple experts.'),
    'c'   : ('No. of Classes', 'Number of classes: e.g., 2 for binary segmentation (foreground and background class).'),
    'il'  : ('Instance Labels', 'Are you providing instance labels (class-aware and instance-aware)?'),
    'up'  : ('Upload Data', 'Upload a zip file. It will be extracted automatically and follow the correct folder structure.', 'https://matjesg.github.io/deepflash2/add_information.html#Naming'),
    'sd'  : ('Sample Data', 'Get sample data for demonstration and testing.'),
    'pretrained': ('Pretrained*', 'Select pretrained weights from the model libray or <new> to use an untrained model (random initialization).', 'https://matjesg.github.io/deepflash2/model_library.html'),
    'n'   : ('No. of Models', '''Number of models within an ensemble \n - If you're experimenting with parameters, try only one model first \n - Depending on the data, ensembles should at least comprise 3-5 models'''),
    's'   : ('Select', 'Train all models (ensemble) or (re-)train specific model.'),
    'n_iter': ('Train Iterations', 'How many times a single model is trained on a mini-batch of the training data.'),
    'lr'  : ('Learning Rate', '''The learning rate controls how quickly or slowly a neural network model learns. \n - Best learning rate depend on your data and other settings, e.g., the optimize \n - Use the learning rate finder to find the best learning rate for your dataset'''),
    'lrf' : ('LR Finder', 'Open to get more information.'),
    'mw'  : ('Mask Weights', 'Open to get more information.'),
    'ts'  : ('Train Settings', 'Open to get more information.'),
    'cfg_load' : ('Configuration', 'Select configuration file (.json) from previous experiments.'),
    'cfg_save' : ('Configuration', 'Save configuration to file (.json).'),
    'tta':  ('Uncertainties', 'Enable uncertainty estimation via test-time augmentation (more reliable and accurate, but slow).'),
    's_val'   : ('Select', 'Ensemble or model to be used for validation.'),

    #Pred
    'img_pred' : ('Image Folder*', 'One folder containing all new images for prediction.', 'https://matjesg.github.io/deepflash2/add_information.html#Naming'),
    'mdl' : ('Model Folder', 'One folder containing the all models of the ensemble. If not selected, latest models from Training will be selected.'),
    'up_pred'  : ('Upload Data', 'Upload a zip file with images or models.'),
    's_pred'   : ('Select', 'Ensemble or model to be used for prediction.'),
}

# Cell
tooltip_css = """<style>
.tooltip {
  position: relative;
  display: inline-block;
}

.tooltip .tooltiptext {
  font-size: small;
  visibility: hidden;
  width: max-content;
  max-width: 280px;
  background-color: white;
  text-align: left;
  border-radius: 3px;
  padding: 3px 3px;
  border: solid 1px black;

  /* Position the tooltip */
  position: absolute;
  z-index: 1;
}

.tooltip:hover .tooltiptext {
  visibility: visible;
}
</style>"""

def set_css_in_cell_output():
    d.display(d.HTML(tooltip_css))

# Cell
def _html_wrap(name, tooltip='', url=None):
    'Wrapper function to create html with tooltip and link to URL'
    if not url:
        return f'<p class="tooltip">&#9432;&nbsp;<span class="tooltiptext">{tooltip}</span></p>{name}'
    else:
        open_tab = 'rel="noopener noreferrer" target="_blank"'#open new tab
        return f"""<p class="tooltip">&#9432;&nbsp;<span class="tooltiptext">{tooltip}<a href="{url}"\
        {open_tab}>&nbsp;More information.</a>'</span></p>{name}"""

# Cell
#from https://code.activestate.com/recipes/577058/
def query_yes_no(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")

# Cell
def _connect_to_drive(path=None):
    "Connect to Google Drive and return path"
    path = path or Path('.')
    if COLAB:
        subprocess.call(['rm', '-rf', '/content/sample_data/'])
        with colab.output.temporary():
            con = query_yes_no("Connect to Google Drive?")
        if con:
            with colab.output.temporary(): colab.drive.mount('/content/drive/')
            path = Path('/content/drive/My Drive')
    return path

# Cell
def _get_model_list(n):
    return ["ensemble"]+[f'model_{x}' for x in range(1, n+1)]

# Cell
def _get_train_sample_data(path):
    url = "https://github.com/matjesg/deepflash2/releases/download/model_library/wue1_cFOS_small.zip"
    urllib.request.urlretrieve(url, path/'sample_data_train.zip')
    unzip(path, path/'sample_data_train.zip')

# Cell
def _get_expert_sample_masks(path):
    path.mkdir(exist_ok=True, parents=True)
    url = "https://github.com/matjesg/bioimage_analysis/raw/master/train_data/lab-wue1/labels/"
    experts = ['expert_'+str(e) for e in range(1,6)]
    for e in  experts:
        (path/e).mkdir(exist_ok=True, parents=True)
        urllib.request.urlretrieve(f'{url}/{e}/0001_cFOS.png', path/e/'mask_1.png')

# Cell
class ZipUpload():
    "Widgets upload and extract zip files"
    def __init__(self, path=None, layout=None):
        self.path = path or Path()
        layout = layout or w.Layout(width='100%')
        self.widget = w.FileUpload(description='Upload .zip', accept='.zip',
                                   multiple=True,layout=layout)
        self.widget.observe(self.extract_content, 'value')

    def extract_content(self, c):
        zip_file = self.path/'upload.zip'
        for fname in self.widget.value:
            content = self.widget.value[fname]['content']
            with open(zip_file, 'wb') as f: f.write(content)
            unzip(self.path, zip_file)

# Cell
class ItemsPerPage:
    "Dropdown to show n items per page"
    drp = w.Dropdown(options=[5,10,20,50,100], description='Show',
                    layout=w.Layout(width='auto', min_width='1px'))
    lyt = w.Layout(flex_flow='column', align_items='flex-end')
    widget = w.HBox(children=[drp],layout=lyt)

# Cell
class BaseParamWidget:
    'Parameter Widget Base Class'

    def __init__(self, config=None):
        config = config or Config()
        self.set_config(config)

        for k,v in self.params.items():
            setattr(v, 'name', k)
            v.observe(self.on_change, 'value')

    def set_config(self, config):
        self.config = config
        for k,v in self.params.items():
            v.value = getattr(config, k)

    def on_change(self, change):
        setattr(self.config, change['owner'].name, change['new'])

    def on_reset_clicked(self, b):
        self.set_config(Config())

    def on_close_clicked(self, b):
        self.widget.layout.display = "none"

# Cell
class BaseUI:
    'Base UI for different steps'
    #_defaults = 'config'
    def __init__(self, config=None, path=None):
        self.config = config or Config()
        self.path = path or Path('.')

    def hide(self):
        self.main_box.layout.display = "none"
        self.sb_acc.layout.display = "none"

    def show(self):
        self.main_box.layout.display = "block"
        self.sb_acc.layout.display = "block"

    def sidebar_change(self, change):
        if change['name']=='selected_index':
            if change['old'] is not None:
                self.main[list(self.sb.keys())[change['old']]].layout.display = "none"
            if change['new'] is not None:
                self.main[list(self.sb.keys())[change['new']]].layout.display = "block"

# Cell
# adapted from https://stackoverflow.com/questions/48056345/jupyter-lab-browsing-the-remote-file-system-inside-a-notebook
class PathSelector():
    "Widgets to browse and select files or directories"
    def __init__(self,start_dir,select_name='Select',select_file=False,tooltip=None):
        self.file        = None
        self.select_file = select_file
        self.hidden      = True
        self.tooltip     = tooltip or 'Click to select directory'

        #Get (and create) dir
        path = Path(start_dir).resolve()
        path.mkdir(parents=True, exist_ok=True)
        self.start_dir, self.cwd, self.path = path, path, path



        #Path Button
        self.button      = w.Button(tooltip=self.tooltip, layout=w.Layout(width='auto'))
        self.button.on_click(self.on_button_clicked)

        #Save Button
        self.button_select = w.Button(description='Save', tooltip='Save Selection', layout=w.Layout(width='auto'))
        self.button_select.on_click(self.on_button_select_clicked)

        #Reset Button
        self.button_reset = w.Button(description='Reset', layout=w.Layout(width='auto'))
        self.button_reset.on_click(self.on_button_reset_clicked)

        #Close Button
        self.button_close = w.Button(description='Close', layout=w.Layout(width='auto'))
        self.button_close.on_click(self.on_button_close_clicked)

        #SelectMultiple
        self.select      = w.SelectMultiple(options=['init'],value=(),rows=10,description='')
        self.select.observe(self.on_update,'value')

        #Display
        self.refresh(self.path)
        self.button.description = select_name
        self.hide()

        self.dialog = w.VBox([w.HBox([self.button_select, self.button_reset, self.button_close]),
                              self.select])

    def show(self):
        self.hidden = False
        self.button.button_style = "info"
        self.button_select.layout.display = "block"
        self.button_close.layout.display = "block"
        self.button_reset.layout.display = "block"
        self.select.layout.display = "block"

    def hide(self):
        self.hidden = True
        self.button.button_style = ""
        self.button_select.layout.display = "none"
        self.button_close.layout.display = "none"
        self.button_reset.layout.display = "none"
        self.select.layout.display = "none"

    def set_path(self, path):
        path = Path(path).resolve()
        path.mkdir(parents=True, exist_ok=True)
        self.start_dir, self.cwd, self.path = path, path, path
        self.refresh('')

    def on_button_clicked(self, b):
        self.refresh('')
        if self.hidden: self.show()
        else: self.hide()

    def on_button_select_clicked(self, b):
        self.path = self.cwd
        self.button.description = f'{self.path.name}'
        self.hide()

    def on_button_reset_clicked(self, b):
        self.cwd = self.start_dir
        self.refresh('')

    def on_button_close_clicked(self, b):
        self.hide()

    def on_update(self,change):
        if len(change['new']) > 0:
            self.refresh(change['new'][0])

    def refresh(self,item):
        path = self.cwd/item

        if path.is_file():
            if self.select_file:
                self.file = path
            else:
                self.select.value = ()

        else: # os.path.isdir(path)
            self.file = None
            self.cwd  = path.resolve()

            # Build list of files and dirs
            keys = ['[..]'] if self.cwd != self.start_dir else []
            for item in sorted(path.iterdir()):
                if item.is_dir():
                    keys.append('['+item.name+']')
                else:
                    keys.append(item.name)

            # Create list of output values
            vals = []
            for k in keys:
                if k[0] == '[':
                    vals.append(k[1:-1]) # strip off brackets
                else:
                    vals.append(k)

            # Update widget
            self.select.options = list(zip(keys,vals))
            with self.select.hold_trait_notifications():
                self.select.value = ()

# Cell
class PathDownloads(PathSelector):
    "Widgets to browse and download files or directories"
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        #Download Button
        if COLAB:
            self.button_select.description = 'Download'
            self.button_select.tooltip = 'Download entire folder or selected file'

        else:
            self.button_select.description = 'Download on Google Colab only'
            self.button_select.disabled = True

    def on_button_select_clicked(self, b):
        if not self.file:
            shutil.make_archive(self.cwd.name, 'zip', self.cwd)
            colab.files.download(f'{self.cwd.name}.zip')
        else:
            for f in self.select.value:
                colab.files.download(self.cwd/f)

# Cell
class PathConfig(PathSelector):
    "Widgets to browse and and load config file"
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        #Download Button
        self.button_select.description = 'Load'
        self.button_select.tooltip = 'Load selected configuration file (.json)'

        #Ouput
        self.output = w.Output()
        self.dialog = w.VBox([self.dialog,self.output])

    def on_button_select_clicked(self, b):
        pass

# Cell
class GTDataSB:
    'Layout for Grund Truth Estimation "Data" Section'

    #Hints
    txt = 'Provide expert segmentation masks'
    hints = w.Label(txt)

    #Grid
    grid = w.GridspecLayout(5, GRID_COLS, width='100%',  grid_gap="0px", align_items='center')
    grid[0, 0] = w.HTML(_html_wrap(*_descr['exp']))
    grid[2, :] = w.HTML('<hr>')
    grid[3, 0] = w.HTML(_html_wrap(*_descr['up_gt']))
    grid[4, 0] = w.HTML(_html_wrap(*_descr['sd']))

    #Data Upload
    grid[3, 1:] = ZipUpload().widget
    sd = w.Button(description='Get',layout=w.Layout(width='auto'),tooltip='Click to download sample data')
    grid[4, 1:] = sd

    #Load Data
    run = w.Button(description='Load Data*', layout=w.Layout(width='auto'))
    grid[1, 1:] = run

    #Final Widget
    widget = w.VBox([hints, grid])

    def __init__(self, path=None):
        path = path or Path('.')
        self.msk  = PathSelector(path, 'Select Parent Folder')
        self.grid[0, 1:] = self.msk.button


# Cell
class GTEstSB:
    'Layout for Grund Truth Estimation "Data" Section'

    #Hints
    txt = 'Select algorithm for ground truth estimation'
    hints = w.HTML(txt)

    grid = w.GridspecLayout(4, GRID_COLS, width='100%',  grid_gap="0px", align_items='center')

    #Labels
    grid[0, 0] = w.HTML(_html_wrap(*_descr['staple']))
    grid[1, 0] = w.HTML(_html_wrap(*_descr['mv']))
    grid[2, :] = w.HTML('<hr>')
    grid[3, 0] = w.HTML('Downloads')

    #Run Staple
    staple = w.Button(description='Run', layout=w.Layout(width='auto'),
                      tooltip='Run simultaneous truth and performance level estimation')
    setattr(staple, 'name', 'staple')
    grid[0, 1:] = staple

    #Run MV
    mv = w.Button(description='Run', layout=w.Layout(width='auto'),
                  tooltip='Run Majority Voting')
    setattr(mv, 'name', 'majority_voting')
    grid[1, 1:] = mv

    #Final Widget
    widget = w.VBox([hints,grid])

    def __init__(self, path=None):
        path = path or Path('.')
        self.down  = PathDownloads(path, 'Select', tooltip='Click to download file or directory')
        self.grid[3, 1:] = self.down.button

# Cell
class GTEstUI(BaseUI):
    'UI for ground truth estimation'

    sections = ['1 - Expert Annotations', '2 - Ground Truth Estimation', '3 - Intercoder Reliability']

    def __init__(self, hide=False, **kwargs):
        super().__init__(**kwargs)

        #Sidebar
        self.sb = {
            'data':GTDataSB(self.path),
            'gt':GTEstSB(self.path)
        }

        #Sidebar Accordion
        self.sb_acc = w.Accordion(children=[x.widget for x in self.sb.values()], layout=w.Layout(grid_area='sidebar'))
        for i, name in enumerate(self.sections):
            self.sb_acc.set_title(i, name)
        self.sb_acc.observe(self.sidebar_change)

        #Main
        self.main = {
            'msk':self.sb['data'].msk.dialog,
            'gt_down':self.sb['gt'].down.dialog,
             **{k:w.Output() for k in self.sb.keys()}
        }
        self.main_box = w.VBox(list(self.main.values()))

        if hide: self.hide()

# Cell
class TrainDataSB(BaseParamWidget, GetAttr):
    'Layout for "Training Data" Section'
    _default = 'config'

    #Hints
    txt = 'Provide training images and segmentation masks'
    hints = w.Label(txt)

    params = {
        'c': w.IntSlider(value=2, min=2, max=10, step=1, layout=w.Layout(width='auto', min_width='1px')),
        'il':w.ToggleButtons(options=[('Yes', True), ('No', False)],tooltips=['You are providing instance labels (class-aware and instance-aware)',
                                                                               'You are not providing only class-aware labels']),
    }

    params['il'].style.button_width = '50px'
    grid = w.GridspecLayout(9, GRID_COLS, width='100%',  grid_gap="0px", align_items='center')

    #Labels
    grid[0, 0] = w.HTML(_html_wrap(*_descr['img']))
    grid[1, 0] = w.HTML(_html_wrap(*_descr['msk']))
    grid[2, 0] = w.HTML(_html_wrap(*_descr['c']))
    grid[2, 1:]= params['c']
    grid[3, 0] = w.HTML(_html_wrap(*_descr['il']))
    grid[3, 1:]= params['il']
    grid[5, :] = w.HTML('<hr>')
    grid[6, 0] = w.HTML(_html_wrap(*_descr['up']))
    grid[7, 0] = w.HTML(_html_wrap(*_descr['sd']))
    grid[8,0] = w.HTML(_html_wrap(*_descr['cfg_load']))

    #Data Upload
    grid[6, 1:] = ZipUpload().widget
    sd = w.Button(description='Get',layout=w.Layout(width='auto'), tooltip='Click to download sample data')
    grid[7, 1:] = sd

    #Load Data
    run = w.Button(description='Load Data*', layout=w.Layout(width='auto', min_width='1px'))
    grid[4, 1:] = run

    #Final Widget
    widget = w.VBox([hints,grid])

    def __init__(self, path=None, **kwargs):
        super().__init__(**kwargs)
        path = path or Path('.')
        self.img  = PathSelector(path, 'Select')
        self.grid[0, 1:] = self.img.button
        self.msk  = PathSelector(path, 'Select')
        self.grid[1, 1:] = self.msk.button
        #Load Config
        self.cfg = PathConfig(path, 'Select Config File', select_file=True)
        self.grid[8, 1:] = self.cfg.button

# Cell
class TrainModelSB(BaseParamWidget, GetAttr):
    'Layout for "Ensemble Training"'
    _default = 'config'

    #Hints
    txt = 'Train Model Ensemble'
    hints = w.Label(txt)

    params = {
        'pretrained': w.Dropdown(options=_pretrained, continuous_update=True, layout=w.Layout(width='auto', min_width='1px')),
        'n': w.IntSlider(min=1, max=10, step=1, continuous_update=True, orientation='horizontal', layout=w.Layout(width='auto', min_width='1px')),
        'n_iter':w.IntSlider(min=100, max=1e4, step=100, continuous_update=True,orientation='horizontal', layout=w.Layout(width='auto', min_width='1px')),
        'lr': w.FloatText(description='', layout=w.Layout(width='auto', min_width='1px'))
    }

    sel = w.Dropdown(options=[],continuous_update=True, layout=w.Layout(width='auto', min_width='1px'))

    #Grid
    grid = w.GridspecLayout(10, GRID_COLS, width='100%',  grid_gap="0px", align_items='center')
    #grid[0, 0] = w.Label('Model Arch')
    grid[0, 0] = w.HTML(_html_wrap(*_descr['pretrained']))
    grid[0, 1:]= params['pretrained']
    grid[1, 0] = w.HTML(_html_wrap(*_descr['n']))
    grid[1, 1:]= params['n']
    grid[2, 0] = w.HTML(_html_wrap(*_descr['n_iter']))
    grid[2, 1:]= params['n_iter']
    grid[3, 0] = w.HTML(_html_wrap(*_descr['s']))
    grid[3, 1:]= sel
    grid[5, :] = w.HTML('<hr>')
    grid[6, 0] = w.HTML(_html_wrap(*_descr['lr']))
    grid[6, 1:]= params['lr']
    grid[7, 0] = w.HTML(_html_wrap(*_descr['lrf']))
    grid[8, 0] = w.HTML(_html_wrap(*_descr['mw']))
    grid[9, 0] = w.HTML(_html_wrap(*_descr['ts']))


    #Run
    run = w.Button(description='Start Training', layout=w.Layout(width='auto'))
    grid[4, 1:] = run

    #LR Finder
    open_lrfinder = w.Button(description='Open', layout=w.Layout(width='auto'))
    grid[7, 1:] = open_lrfinder

    #Custom Mask Weights
    open_mw = w.Button(description='Customize', layout=w.Layout(width='auto'))
    grid[8, 1:] = open_mw

    #Custom Data Aug
    open_par = w.Button(description='Customize', layout=w.Layout(width='auto'))
    grid[9, 1:] = open_par

    #Final Widget
    widget = w.VBox([hints,grid])

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.sel.options = _get_model_list(self.config.n)
        self.params['n'].observe(self.sel_update, 'value')

    def sel_update(self, change):
        self.sel.options = _get_model_list(change['new'])

# Cell
class TrainValidSB(BaseParamWidget, GetAttr):
    'Layout for "Validation" Section'
    _default = 'config'

    #Hints
    txt = 'Validate Model Ensemble'
    hints = w.Label(txt)

    params = {
        'tta': w.ToggleButtons(options=[('Yes', True), ('No', False)],
                               tooltips=['Enable Test-Time Augmentation','Disable Test-Time Augmentation'])
    }

    params['tta'].style.button_width = '50px'

    #Grid
    grid = w.GridspecLayout(5, GRID_COLS, width='100%',  grid_gap="0px", align_items='center')
    grid[0, 0] = w.HTML(_html_wrap(*_descr['s_val']))
    grid[1, 0] = w.HTML(_html_wrap(*_descr['tta']))
    grid[1, 1:]= params['tta']
    grid[3, :] = w.HTML('<hr>')
    grid[4, 0] = w.HTML('Downloads')

    #Model
    sel = w.Dropdown(continuous_update=True, layout=w.Layout(width='auto', min_width='1px'))
    grid[0, 1:] = sel

    #Res
    run = w.Button(description='Run prediction*', layout=w.Layout(width='auto'))
    grid[2, 1:] = run

    #Final Widget
    widget = w.VBox([hints,grid])

    def __init__(self, path=None, **kwargs):
        super().__init__(**kwargs)
        path = path or Path('.')
        self.sel.options = _get_model_list(self.config.n)
        self.down  = PathDownloads(path, 'Select', tooltip='Click to download models, predictions or validation results')
        self.grid[4, 1:] = self.down.button

    def sel_update(self, change):
        self.sel.options = _get_model_list(change['new'])

# Cell
class LRWidget:
    'Widget for Learning Rate Finder'

    #Start Button
    tt_start = 'Start the Learning Rate Finder'
    run = w.Button(description='Start', tooltip=tt_start)

    #Close Button
    tt_close = 'Close Learning Rate Finder. ATTENTION: This will not interrupt the execution)'
    button_close = w.Button(description='Close', tooltip=tt_close)

    #Lbl
    html = _html_wrap('More information', 'Click here for more information on the learning rate finder',
                      'https://docs.fast.ai/callback.schedule.html#Learner.lr_find')
    lbl = w.HTML(html)

    #Output
    output = w.Output()

    #Box
    widget = w.Accordion(children=[w.VBox([w.HBox([run, button_close]), lbl, output])])
    widget.set_title(0, 'Learning Rate Finder')

    def __init__(self):
        self.widget.layout.display = "none"
        self.button_close.on_click(self.on_close_clicked)

    def on_close_clicked(self, b):
        self.widget.layout.display = "none"

# Cell
class BasePopUpParamWidget(BaseParamWidget):
    'Parameter Pop-Up Widget Base Class'

    #Reset Button
    tt_reset = 'Reset to defaults'
    button_reset = w.Button(description='Reset', tooltip=tt_reset)

    #Close Button
    tt_close = 'Close Widget'
    button_close = w.Button(description='Close', tooltip=tt_close)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.button_reset.on_click(self.on_reset_clicked)
        self.button_close.on_click(self.on_close_clicked)

# Cell
class ParamWidget(BasePopUpParamWidget, GetAttr):
    'Widget for custom training parameters'
    _default = 'config'
    params = {
        'arch' : w.Dropdown(options=_archs, layout=w.Layout(width='auto', min_width='1px')),
        'mpt': w.ToggleButtons(options=[('Yes', True), ('No', False)],
                              tooltips=['Enable Mixed-Precision Training','Disable Mixed-Precision Training']),
        'bs':w.IntSlider(min=2, max=16, step=2,layout=w.Layout(width='auto', min_width='1px')),
        'wd':w.FloatText(min=0, max=1,layout=w.Layout(width='auto', min_width='1px')),
        'optim':w.Dropdown(options=_optim_dict.keys(), layout=w.Layout(width='auto', min_width='1px')),
        'light':w.FloatSlider(min=0, max=1, layout=w.Layout(width='auto', min_width='1px')),
        'flip':w.ToggleButtons(options=[('Yes', True), ('No', False)]),
        'rot':w.IntSlider( min=0, max=360, step=5, layout=w.Layout(width='auto', min_width='1px')),
        'def_grid':w.IntSlider(min=0, max=350, step=10, layout=w.Layout(width='auto', min_width='1px')),
        'def_mag':w.IntSlider(min=0, max=100, layout=w.Layout(width='auto', min_width='1px'))
    }


    params['mpt'].style.button_width = '25px'
    params['flip'].style.button_width = '25px'

    #Close Button
    tt_show = 'Show example'
    button_show = w.Button(description='Show', tooltip=tt_show)

    #Hint
    lbl = w.Label('Settings are saved automatically')

    #Grid
    grid = w.GridspecLayout(12, 2, width='400px',  grid_gap="0px", align_items='center')
    grid[0, 0] = w.Label('Model Architecture')
    grid[0, 1] = params['arch']
    grid[1, 0] = w.Label('Mini-Batch Size')
    grid[1, 1] = params['bs']
    grid[2, 0] = w.HTML('<a href="https://docs.fast.ai/callback.fp16.html">Mixed Precision Training </a>')
    grid[2, 1] = params['mpt']
    grid[3, 0] = w.HTML('<a href="https://arxiv.org/abs/1711.05101">Weight Decay</a>')
    grid[3, 1] = params['wd']
    grid[4, 0] = w.HTML('<a href="https://docs.fast.ai/optimizer.html">Optimizer</a>')
    grid[4, 1] = params['optim']
    grid[5, :] = w.HTML('<hr>')
    grid[6, :] = w.HTML('<b>Data Augmentation</b>')
    grid[7, 0] = w.HTML('<a href="https://matjesg.github.io/deepflash2/data.html#Data-augmentation">Flip</a>')
    grid[7, 1] = params['flip']
    grid[8, 0] = w.HTML('<a href="https://matjesg.github.io/deepflash2/data.html#Data-augmentation">Rotation (max. degrees)</a>')
    grid[8, 1] = params['rot']
    grid[9, 0] = w.HTML('<a href="https://matjesg.github.io/deepflash2/data.html#Data-augmentation">Deformation Grid Size</a>')
    grid[9, 1] = params['def_grid']
    grid[10, 0] = w.HTML('<a href="https://matjesg.github.io/deepflash2/data.html#Data-augmentation">Deformation Magnitude</a>')
    grid[10, 1] = params['def_mag']
    grid[11, 0] = w.HTML('<a href="https://docs.fast.ai/vision.augment.html">Brightness (max. lighting)</a>')
    grid[11, 1] = params['light']

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.widget = w.Accordion(children=[w.VBox([w.HBox([self.button_reset, self.button_close]),self.lbl,self.grid])])
        self.widget.set_title(0, 'Training Parameters')
        self.widget.layout.display = "none"

# Cell
class MWWidget(BasePopUpParamWidget, GetAttr):
    'Widget to customize mask weights'
    _default = 'config'
    params = {
    'bwf':w.IntSlider(min=1, max=50, continuous_update=True, layout= w.Layout(width='auto')),
    'fbr':w.FloatSlider(min=0, max=1, continuous_update=True, layout= w.Layout(width='auto')),
    'bws':w.IntSlider(min=1, max=20, continuous_update=True, layout= w.Layout(width='auto')),
    'fds':w.IntSlider(min=1, max=20, continuous_update=True, layout= w.Layout(width='auto'))}
    out = w.Output()

    #Close Button
    tt_show = 'Show example'
    button_show = w.Button(description='Show', tooltip=tt_show)

    #Select
    select = w.Dropdown(options=["unet_deepflash2",  "unet_falk2019", "unet_ronnberger2015"], layout=w.Layout(width='auto', min_width='1px'))

    #Hint
    lbl = w.HTML('Settings are saved automatically. Click <a href="https://matjesg.github.io/deepflash2/data.html#Weight-Calculation">here</a> for detailed information.')


    #Grid
    grid = w.GridspecLayout(6, 2, width='400px',  grid_gap="0px", align_items='center')
    grid[0, 0] = w.Label('Border Weight Factor')
    grid[0, 1] = params['bwf']
    grid[1, 0] = w.Label('Border Weight Sigma')
    grid[1, 1] = params['bws']
    grid[2, 0] = w.Label('Forground-Background Ratio')
    grid[2, 1] = params['fbr']
    grid[3, 0] = w.Label('Forground Distance Sigma')
    grid[3, 1] = params['fds']
    grid[4, :] = w.HTML('<hr>')
    grid[5, :] = w.HTML('<b>Visualization</b>')

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.widget = w.Accordion(children=[w.VBox([w.HBox([self.button_reset, self.button_close]),
                                           self.lbl,
                                           self.grid,
                                           w.HBox([self.button_show, self.select]),
                                           self.out])]
                         )
        self.widget.set_title(0, 'Custom Mask Weights')
        self.widget.layout.display = "none"

# Cell
class TrainUI(BaseUI):
    'UI for ensemble training'
    sections = ['1 - Data', '2 - Ensemble Training', '3 - Validation']

    def __init__(self, hide=False, **kwargs):
        super().__init__(**kwargs)

        #Sidebar
        self.sb = {
            'data':TrainDataSB(path=self.path, config=self.config),
            'train':TrainModelSB(config=self.config),
            'valid':TrainValidSB(path=self.path, config=self.config),
        }
        self.sb['train'].open_lrfinder.on_click(self.open_lrfinder)
        self.sb['train'].open_mw.on_click(self.open_mw)
        self.sb['train'].open_par.on_click(self.open_par)
        #Update model options from train in valid
        self.sb['train'].params['n'].observe(self.sb['valid'].sel_update, 'value')

        #Sidebar Accordion
        self.sb_acc = w.Accordion(children=[x.widget for x in self.sb.values()], layout=w.Layout(grid_area='sidebar'))
        for i, name in enumerate(self.sections):
            self.sb_acc.set_title(i, name)
        self.sb_acc.observe(self.sidebar_change)

        #Extra
        self.xtr = {
            'lr':LRWidget(),
            'mw':MWWidget(config=self.config),
            'param':ParamWidget(config=self.config)
        }

        #Main
        self.main = {
            'img':self.sb['data'].img.dialog,
            'msk':self.sb['data'].msk.dialog,
            'cfg':self.sb['data'].cfg.dialog,
            'lr':self.xtr['lr'].widget,
            'mw':self.xtr['mw'].widget,
            'param':self.xtr['param'].widget,
            'down':self.sb['valid'].down.dialog,
             **{k:w.Output() for k in self.sb.keys()}
        }
        self.main_box = w.VBox(list(self.main.values()))



        if hide: self.hide()

    def set_config(self, config):
        self.sb['data'].set_config(config)
        self.sb['train'].set_config(config)
        self.xtr['param'].set_config(config)
        self.xtr['mw'].set_config(config)

    def open_lrfinder(self, b):
        self.main['lr'].layout.display = "block"

    def open_mw(self, b):
        self.main['mw'].layout.display = "block"

    def open_par(self, b):
        self.main['param'].layout.display = "block"


# Cell
class PredInputSB:
    'Layout for "Data and Ensemble" Section'

    #Hints
    txt = 'Provide new images and models'
    hints = w.Label(txt)

    grid = w.GridspecLayout(5, GRID_COLS, width='100%',  grid_gap="0px", align_items='center')

    #Labels
    grid[0, 0] = w.HTML(_html_wrap(*_descr['img_pred']))
    grid[1, 0] = w.HTML(_html_wrap(*_descr['mdl']))
    grid[3, :] = w.HTML('<hr>')
    grid[4, 0] = w.HTML(_html_wrap(*_descr['up_pred']))
    #grid[5, 0] = w.Label('Sample Data')

    #Data Upload
    grid[4, 1:] = ZipUpload().widget
    #grid[5, 1:] = TrainSampleData(layout=w.Layout(width='auto')).widget

    #Load Data
    run = w.Button(description='Load*', layout=w.Layout(width='auto', min_width='1px'))
    grid[2, 1:] = run

    #Final Widget
    widget = w.VBox([hints,grid])

    def __init__(self, path=None):
        path = path or Path('.')
        self.img  = PathSelector(path, 'Select')
        self.grid[0, 1:] = self.img.button
        self.ens  = PathSelector(path, 'Select')
        self.grid[1, 1:] = self.ens.button

# Cell
class PredSB(BaseParamWidget, GetAttr):
    'Layout for "Prediction and Quality Control" Section'
    _default = 'config'

    #Hints
    txt = 'Predict segmentations'
    hints = w.Label(txt)

    params = {
        'pred_tta': w.ToggleButtons(options=[('Yes', True), ('No', False)],
                                    tooltips=['Enable Test-Time Augmentation','Disable Test-Time Augmentation'])
    }
    params['pred_tta'].style.button_width = '50px'

    #Grid
    grid = w.GridspecLayout(4, GRID_COLS, width='100%',  grid_gap="0px", align_items='center')
    #grid[0, 0] = w.HTML(_html_wrap(*_descr['s_pred']))
    grid[0, 0] = w.HTML(_html_wrap(*_descr['tta']))
    grid[0, 1:] = params['pred_tta']
    grid[2, :] = w.HTML('<hr>')
    grid[3, 0] = w.HTML('Downloads')

    #Model
    #model = w.Dropdown(options=["ensemble",  "model_1", "model_2"],  continuous_update=True,
    #                  layout=w.Layout(width='auto', min_width='1px'))
    #grid[0, 1:] = model

    #Res
    run = w.Button(description='Predict and show results*', layout=w.Layout(width='auto'))
    grid[1, 1:] = run

    #Final Widget
    widget = w.VBox([hints,grid])

    def __init__(self, path=None, **kwargs):
        super().__init__(**kwargs)
        path = path or Path('.')
        self.down  = PathDownloads(path, 'Select', tooltip='Click to download')
        self.grid[3, 1:] = self.down.button

# Cell
class PredUI(BaseUI):
    'UI for prediction of new data'

    sections = ['1 - Data and Ensemble', '2 - Prediction and Quality Control']

    def __init__(self, hide=False, **kwargs):
        super().__init__(**kwargs)

        #Sidebar
        self.sb = {
            'data':PredInputSB(path=self.path),
            'pred':PredSB(path=self.path, config=self.config),
        }

        #Sidebar Accordion
        self.sb_acc = w.Accordion(children=[x.widget for x in self.sb.values()], layout=w.Layout(grid_area='sidebar'))
        for i, name in enumerate(self.sections):
            self.sb_acc.set_title(i, name)
        self.sb_acc.observe(self.sidebar_change)

        #Main
        self.main = {
            'img':self.sb['data'].img.dialog,
            'ens':self.sb['data'].ens.dialog,
            'down':self.sb['pred'].down.dialog,
             **{k:w.Output() for k in self.sb.keys()}
        }
        self.main_box = w.VBox(list(self.main.values()))

        if hide: self.hide()

    def open_lrfinder(self, b):
        self.main['lr'].layout.display = "block"

# Cell
class GUI(GetAttr):
    'GUI for deepflash2'
    _default = 'config'

    #Header and Footer
    head = "<h4 style='text-align:center;background-color:lightgray'>deepflash</h4>"
    header = w.HTML(value=head, layout=w.Layout(width='auto', grid_area='header'))
    foot = "<h6 style='text-align:left;background-color:lightgray'>&nbsp; </h6>"
    #foot = ""
    footer = w.HTML(value=foot, layout=w.Layout(width='100%', grid_area='footer'))

    #Category Buttons
    cat_btns = {
        'gt':w.Button(description='GT Estimation', layout=w.Layout(flex='1 1 0%',width='auto')),
        'train':w.Button(description='Training', layout=w.Layout(flex='1 1 0%',width='auto')),
        'pred':w.Button(description='Prediction', layout=w.Layout(flex='1 1 0%', width='auto'))
    }
    cat_btns_box = w.Box(children=list(cat_btns.values()), layout=w.Layout(grid_area='cat_btns'))

    def __init__(self):
        get_ipython().events.register('pre_run_cell', set_css_in_cell_output)
        self.config = Config()
        self.base_path = _connect_to_drive().resolve()

        #Project Dir
        self.proj = PathSelector(self.base_path, 'Project Folder', tooltip='Project Folder \ndefault: <deepflash2>')
        self.proj.button_select.on_click(self.set_project_dir)
        self.config.proj_dir = self.base_path/self.proj_dir

        #Click Category Buttons
        for v in self.cat_btns.values():
            v.on_click(self.cat_clicked)

        #Categories
        self.gt = GTEstUI(hide=True, path=self.base_path)
        self.train = TrainUI(hide=True,path=self.base_path, config=self.config)
        self.pred = PredUI(hide=True, path=self.base_path)
        self.cat = {'gt':self.gt, 'train':self.train, 'pred':self.pred}

        #Connect Buttons
        ## GT Estimation
        self.gt.sb['data'].run.on_click(self.gt_data_run_clicked)
        self.gt_data_n_items = ItemsPerPage()
        self.gt_data_n_items.drp.observe(self.gt_data_n_items_change, 'value')
        self.gt.sb['data'].sd.on_click(self.gt_data_sd_clicked)
        self.gt.sb['gt'].staple.on_click(self.gt_ref_clicked)
        self.gt.sb['gt'].mv.on_click(self.gt_ref_clicked)

        ## Train
        self.train.sb['data'].run.on_click(self.train_data_run_clicked)
        self.train.sb['data'].sd.on_click(self.train_data_sd_clicked)
        self.train.sb['data'].cfg.button_select.on_click(self.train_data_load_cfg_clicked)
        self.train_data_n_items = ItemsPerPage()
        self.train_data_n_items.drp.observe(self.train_data_n_items_change, 'value')
        self.train.sb['train'].run.on_click(self.train_run_clicked)
        #self.train.sb['train'].params['n'].observe(self.train_n_change, 'value')
        self.train.sb['valid'].run.on_click(self.train_valid_run_clicked)

        self.train.xtr['lr'].run.on_click(self.lr_start_clicked)
        #self.train.xtr['param'].run.on_click(self.lr_start_clicked)

        ## Pred
        self.pred.sb['data'].run.on_click(self.pred_data_run_clicked)
        self.pred_data_n_items = ItemsPerPage()
        self.pred_data_n_items.drp.observe(self.pred_data_n_items_change, 'value')
        self.pred.sb['pred'].run.on_click(self.pred_run_clicked)

        self._set_download_dirs()
        self.star_info = w.Label('*Required')
        self.star_info.layout.display = "none"

        box_sb = w.VBox(children=[x.sb_acc for x in self.cat.values()]+[self.star_info], layout=w.Layout(grid_area='sidebar'))
        box_main = w.VBox(children=[x.main_box for x in self.cat.values()], layout=w.Layout(grid_area='main'))
        box_proj = w.VBox(children=[self.proj.button, self.proj.dialog], layout=w.Layout(grid_area='proj', flex_flow='column', align_items='flex-start'))

        gb = w.GridBox(children=[self.header, self.cat_btns_box, box_proj, box_sb, box_main, self.footer],
                       layout=w.Layout(
                           width='100%',
                           grid_template_columns='350px auto',
                           grid_gap='0px 0px',
                           grid_template_areas='''
                           "header header"
                           "cat_btns proj"
                           "sidebar main"
                           "footer footer"
                           '''))
        display(gb)

    def _set_download_dirs(self):
        self.gt.sb['gt'].down.set_path(Path(self.proj_dir)/self.gt_dir)
        self.train.sb['valid'].down.set_path(Path(self.proj_dir)/self.train_dir)
        self.pred.sb['pred'].down.set_path(Path(self.proj_dir)/self.pred_dir)
        self.pred.sb['data'].ens.set_path(Path(self.proj_dir)/self.train_dir/self.ens_dir)

    def set_project_dir(self, b):
        self.config.proj_dir = str(self.proj.path)
        self._set_download_dirs()

    def cat_clicked(self, b):
        #first execution only
        #if not self.project_path.is_dir(): self.project_path.mkdir(parents=True)
        self.star_info.layout.display = "block"
        for k,v in self.cat_btns.items():
            if v==b:
                v.button_style = 'info'
                self.cat[k].show()
            else:
                v.button_style = ''
                self.cat[k].hide()

    def set_config(self, config):
        self.config=config
        self.train.set_config(config)

    # GT Estimation
    def gt_data_run_clicked(self, b):
        out = self.gt.main['data']
        out.clear_output()
        exp_folder = self.gt.sb['data'].msk.path.relative_to(self.base_path)
        with out:
            self.gt_est = GTEstimator(exp_folder, config=self.config, path=self.base_path)
            display(self.gt_data_n_items.widget)
            self.gt_est.show_data(max_n=5)

    #GT Data Items
    def gt_data_n_items_change(self, change):
        out = self.gt.main['gt']
        with out:
            display(self.gt_data_n_items.widget)
            self.gt_est.show_data(max_n=change['new'])

    def gt_data_sd_clicked(self, b):
        out = self.gt.main['data']
        out.clear_output()
        with out:
            path = Path(self.proj_dir)/'sample_data'/'expert_segmentations'
            print(f'Dowloading expert sample data into {path.relative_to(self.base_path)}')
            _get_expert_sample_masks(path)
            self.gt.sb['data'].msk.path = path
            print(f'Click "Load Data" to continue.')

    def gt_ref_clicked(self, b):
        out = self.gt.main['gt']
        out.clear_output()
        save_dir = (Path(self.proj_dir)/self.gt_dir/b.name).relative_to(self.base_path)
        res_out = w.Output()
        with out:
            display(res_out)
            self.gt_est.gt_estimation(method=b.name, save_dir=save_dir)
        with res_out:
            print(f'Overall similarity to {b.name}')
            display(pd.DataFrame(self.gt_est.df_agg.mean()))
            print('------------------')
            print(f'Overall similarity to {b.name} by expert')
            display(self.gt_est.df_agg)
            print('------------------')

    # Train
    def train_data_run_clicked(self, b):
        out = self.train.main['data']
        out.clear_output()
        with out: print('Loading data. Please wait')
        image_folder = self.train.sb['data'].img.path.relative_to(self.base_path)
        mask_folder = self.train.sb['data'].msk.path.relative_to(self.base_path)
        ens_folder = (Path(self.proj_dir)/self.train_dir/self.ens_dir).relative_to(self.base_path)

        with out:
            self.el = EnsembleLearner(image_folder, mask_folder, self.config, self.base_path, ens_folder)
            display(self.train_data_n_items.widget)
            self.el.ds.show_data(overlay=True, max_n=5)
            plt.show()

    #Data Items
    def train_data_n_items_change(self, change):
        out = self.train.main['data']
        with out:
            display(self.train_data_n_items.widget)
            self.el.ds.show_data(overlay=True, max_n=change['new'])
            plt.show()

    def train_data_sd_clicked(self, b):
        out = self.train.main['data']
        out.clear_output()
        with out:
            path = Path(self.proj_dir)/'sample_data'
            print(f'Dowloading sample data into {path.relative_to(self.base_path)}')
            _get_train_sample_data(path)
            self.train.sb['data'].img.path = path/'images'
            self.train.sb['data'].msk.path = path/'masks'
            print(f'Click "Load Data" to continue.')

    def train_data_load_cfg_clicked(self, b):
        cfg = self.train.sb['data'].cfg
        cfg.output.clear_output()
        with cfg.output:
            path = cfg.cwd/cfg.select.value[0]
            self.config.load(path)
        time.sleep(3)
        out.clear_output()

    def train_run_clicked(self, b):
        out = self.train.main['train']
        out.clear_output()
        with out:
            try:
                assert type(self.el)==EnsembleLearner
                print('Starting training. This may take up to a few hours - watch the logs below.')
            except:
                print('Please load data first!')

        sel = self.train.sb['train'].sel.value
        self.el.set_n(self.n)
        for i in range(1, self.n+1):
            if (sel != 'ensemble') and (sel != f'model_{i}'): continue
            with out: print(f'Training of model {i}')
            if COLAB:
                with colab.output.temporary(): self.el.fit(i)
            else:
                with out: self.el.fit(i)
            with out:
                print(f'Metrics for model {i} of {self.n}')
                self.el.recorder[i].plot_metrics()

    def train_valid_run_clicked(self, b):
        out = self.train.main['valid']
        out.clear_output()
        sel = self.train.sb['valid'].sel.value

        model_no = None if sel == 'ensemble' else int(sel[6:])
        with out: print(f'Validating {sel}. This may take a while!')
        if COLAB:
            with colab.output.temporary():
                self.el.get_valid_results(model_no, use_tta=self.tta)
        else:
            with out:
                self.el.get_valid_results(model_no, use_tta=self.tta)
        out.clear_output()
        save_dir = (Path(self.proj_dir)/self.train_dir/self.val_dir).relative_to(self.base_path)
        with out: self.el.show_valid_results(model_no, save_dir=save_dir)

    #Lr finder
    def lr_open(self,b):
        self.lrfinder.widget.layout.display = "block"

    def lr_start_clicked(self, b):
        out = self.train.xtr['lr'].output
        out.clear_output()
        with out:
            print('Starting Learning Rate Finder. Please Wait.')
        if COLAB:
            with colab.output.temporary():
                sug_lrs, rec = self.el.lr_find(show_plot=False)
        else:
            with out:
                sug_lrs, rec = self.el.lr_find(show_plot=False)
        with out:
            print(sug_lrs)
            rec.plot_lr_find()
            plt.show()

    #Mask weights
    def mw_open(self,b):
        self.mw.widget.layout.display = "block"

    #Train Settings
    def par_open(self,b):
        self.par.widget.layout.display = "block"

    def mw_on_show_clicked(self, b):
        pass

    # Prediction
    def pred_data_run_clicked(self, b):
        out = self.pred.main['data']
        out.clear_output()
        with out: print('Loading data. Please wait')
        image_folder = self.pred.sb['data'].img.path.relative_to(self.base_path)
        ens_folder = self.pred.sb['data'].ens.path.relative_to(self.base_path)

        with out:
            self.el_pred = EnsembleLearner(image_folder, config=self.config, path=self.base_path, ensemble_dir=ens_folder)
            self.el_pred.get_models()
            display(self.pred_data_n_items.widget)
            self.el_pred.ds.show_data(max_n=5, figsize = (5,5))
            plt.show()

    def pred_data_n_items_change(self, change):
        out = self.pred.main['data']
        with out:
            display(self.pred_data_n_items.widget)
            self.el_pred.ds.show_data(max_n=change['new'], figsize = (5,5))
            plt.show()

    def pred_run_clicked(self, b):
        out = self.pred.main['pred']
        out.clear_output()
        with out: print('Predicting segmentation masks. Please wait...')
        if COLAB:
            with colab.output.temporary():
                self.el_pred.get_ensemble_results(self.el_pred.files, use_tta=self.pred_tta)
        else:
            with out:
                self.el_pred.get_ensemble_results(self.el_pred.files, use_tta=self.pred_tta)
        with out:
            self.el_pred.show_ensemble_results()

        get_ensemble_results